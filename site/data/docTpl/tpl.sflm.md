#Static File Library Manager#
Автозагрузчик JavaScript объектов

Предпосылки создания автозагрузчика JS-файлов с необходимыми объектами/классами вылились из концепции
fullstack-фреймворка, где существуют компоненты не только на стороне сервера, но и клиент-серверные компоненты,
представляющие сотобой набор из контроллера, моделей базы данных, конфигурации, классов сервероной бизнес логики,
а так же клиентской части: визуальное отображение (рендеринг HTML), та же бизнес-логика и классы, компоненты фреймворка,
необходимые для реализации всего этого. Создавая диалог или поле формы, которое требует JS-логики. Каждый раз
мы нуждаемся в автозагрузке базовых объектов. Как Вы бы вели себя при классическом подходе? Подключили бы
`<script src=".../someJQueryComponent.js"></script>`. И остались бы счастиливы. Но в больших приложения
компоненты не являются нечтом монолитным. Они состоят из множества саб-классов и саб-объектов. В Ngn для того, что
бы создать диалог с формой, нужно подключить файл Ngn.Dialog.RequestForm. Но будем ли мы знать о том, что нам нужно это сделать,
если поле формы использует класс `Ngn.Dialog.Abc` наследуемый от `Ngn.Dialog.RequestForm`. Конечно да. И мы подключим этот
`Ngn.Dialog.RequestForm` и `Ngn.Dialog.Abc`, а потом сольём их в один файл. Как же быть, когда мы новый элемент 
формы создаётся через web-интерфейс контент-менеджеров? Элемент формы, который использует совершенно уникальный для,
него JS-код который не нужен был до этого момента. Конечно. Ответ один. Весь JS-код для всех типов полей должен
быть подключён всегда. Но как быть, если в нашем фреймворке сотня типов полей? И эта сотня типов использует ещё
около сотни базовых объектов-хелперов, объединяющих функции вроде работы со строками и т.п. Подключать все имеющиеся
в фреймворке JS-объекты не кажется правельным. А отслеживать все эти связи вручную - не лёгкая и адски-рутинная задача.
На помощь приходит Sflm. Он сем отследит связи, подключит только нужное в нужном порядке.

Посмотрите на лог вызовов библиотеки, что бы примерно понять как работает автозагрузчик.

Первый пример - пустой вызов. Подключаются базовые библиотеки.
{console run "Sflm::$output = true; Sflm::$uploadPath = '/home/user/ngn-env/temp'; Sflm::setFrontendName('a'); Sflm::clearCache(); Sflm::frontend('js')->store();" doc/init.php}

В следующем примере происходит добавление всего одного класса `Ngn.Dialog`. Посмотрите какие необходимые библиотеки подключаются в результате:
{console run "Sflm::$output = true; Sflm::$uploadPath = '/home/user/ngn-env/temp'; Sflm::setFrontendName('a'); Sflm::clearCache(); Sflm::frontend('js')->addClass('Ngn.Dialog'); Sflm::frontend('js')->store();" doc/init.php}

##Архитектура##
Sflm работает в контексте _sflm-фронтенда_. sflm-фронтенд - это своеобразное хранилище объектов,
которое инкрементально пополняется каждый раз, когда происходит добавление нового объекта.
sflm-фронтенд определяется до создания контроллера. Контроллер - это то место, где начинается
бизнес-логика, а значит и подключения JS-объектов. Так что точкой определения sflm-фронтенда является
роутер. Это то место где вы ещё в силах выбрать sflm-фронтенд.

    // метод Роутера
    protected function init() {
      Sflm::setFrontendName('frontendName');
    }

Далее выполняется вся бизнес-логика от экшенов контроллера до php-кода находящегося в шаблонах. Добавление
JS-объектов может происходить где угодно, но должно закончиться до выполнения метода `SflmFrontendJs::store()`.
Он вызывается в `CtrlBase::getOutput()` уже после вывода.

##Добавление JS-объектов##
Основным и самым удобным методом для добавления объектов является `SflmFrontendJs::addClass()`. Он автоматически ищет
объект или класс во всех каталогах со статическими файлами `Sflm::$absBasePaths`. Для стандартного проекта
это будут каталоги `WEBROOT_PATH.'/m'` и `NGN_PATH.'/u'`. Объектами/классами в Sflm являются файлы формата
`Ngn.asd.Abc`/`Ngn.Asd.Abc`/`Ngn.Asd.dsa.Abc`/ и т.п. Последний кусок (часть имени файла без расширения разбитая точками)
должна начинаться с большой буквы. Объект должен обязательно находиться в неймспейсе `Ngn`. Это обусловлено
использованием в системе других JS-компонентов, подключаемых статически, не отвечающих конвенциям, необходимым
для правильной работы Sflm.

    Sflm::frontend('js')->addClass('Ngn.Name');

##Добавление статических путей в JS-код##

##Подключение зависимостей из JS-файлов##
При объектом подходе в клиентской разработке бывает удобно представлять JS-класс,
как готовый контрол (визуальный компонент). В таких случая кроме JS-кода, нужен ещё и CSS.

##Отладка отдельных файлов##
{tag Отладка CSS/JS файлов}
При работе с JS-библиотекми, собранными через Sflm важно сохранить быстроту разработки и отладки, но при этом не
потерять фишки по автоматическому отслеживанию связей. Ведь одни обеспечивают надёжность сборки компонентов и
уберегают от лишней рутины. Sflm имеет встроенный механизм отладки отдельных файлов на локальном сервере.
При этом важно иметь их первоначальную версию на удаленном dev-сервере, что бы сработало подключение необходимых
в файле компоненотов, средствами Sflm. Что бы начать отладку отдельных файлов используйте следующие статисеские свойства,
переопределим их в `init.php` файле проекта.

Настройки для отладки одного файла с именем `Ngn.Dialog.js`: 

    Sflm::$debugUrl = 'http://localhost:8888';
    Sflm::$debugPaths = [
      'js' => [
        'Ngn.Dialog.js'
      ]
    ];
    
Или так для всей папки:
    
    Sflm::$debugPaths = [
      'js' => [
        'i/ngn/dialog/'
      ]
    ];
    
После этого останется лишь запустить локальный веб-сервер в папке проекта

    php -S localhost:8888
    
##Текущий список файлов в sflm-фронтенде##
Текущее содержание sflm-фронтенда можно посмотреть через командную строку. Для этого
существует cli-утилита `sflm`.

{console sflm docdemo}
{console sflm docdemo paths default css}
{console sflm docdemo paths default js}
